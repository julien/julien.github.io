<!DOCTYPE html>
<html>
  <head>
    <style>
      body{width:100%;height:100%;overflow:hidden;
        text-align:center;font: normal 1.8em monospace;margin:0;}
    </style>
  </head>
  <body>
    <div align="center">
      <canvas id="canvas" width="640" height="480"></canvas>
    </div>

    <script id="shader-vs" type="x-shader/x-vertex">
      attribute vec3 aVertexPosition;
      void main() {
        gl_Position = vec4(aVertexPosition, 1.0);
      }
    </script>
    <script id="shader-fs" type="x-shader/x-fragment">
      #ifdef GL_ES
      // precision highp float;
      precision mediump float;
      #endif

      uniform float time;
      uniform vec2 resolution;
      uniform vec2 mouse;
      uniform sampler2D tex;

      void main() {
        vec2 cPos = -1.0 + 2.0 * gl_FragCoord.xy / resolution.xy;
        float cLength = length(cPos * time) / 1.0;
        vec2 uv = gl_FragCoord.xy / resolution.xy + (cPos / cLength) * cos(cLength * 12.0 - time * 22.0) * 0.03;
        vec3 col = texture2D(tex, uv).xyz;
        gl_FragColor = vec4(col, 1.0);
      }
    </script>
    <script>
      (function() {
        var canvas
          , gl
          , squareVertexPositionBuffer
          , shaderProg
          , texture
          , startTime
          , video;

        function initGl(canvas) {
          try {
            gl = canvas.getContext('experimental-webgl');
            gl.viewportWidth = canvas.width;
            gl.viewportHeight = canvas.height;
          } catch (e) {
            alert('could not initialize webGL');
            return;
          }
        }

        function getShader(gl, id) {
          var script, str, shader;
          script = document.getElementById(id);
          if (!gl || !script || script.nodeType !== 1) {
            return null;
          }
          str = script.textContent;

          if (script.type === 'x-shader/x-vertex') {
            shader = gl.createShader(gl.VERTEX_SHADER);
          } else if (script.type === 'x-shader/x-fragment') {
            shader = gl.createShader(gl.FRAGMENT_SHADER);
          } else {
            return null;
          }
          gl.shaderSource(shader, str);
          gl.compileShader(shader);
          if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert('could not compile shaders');
            return;
          }
          return shader;
        }

        function initShaders() {
          var vShader, fShader;
          vShader = getShader(gl, 'shader-vs');
          fShader = getShader(gl, 'shader-fs');

          shaderProg = gl.createProgram();
          gl.attachShader(shaderProg, vShader);
          gl.attachShader(shaderProg, fShader);
          gl.linkProgram(shaderProg);

          if (!gl.getProgramParameter(shaderProg, gl.LINK_STATUS)) {
            alert('could not link shader program');
            return;
          }
          gl.useProgram(shaderProg);
          shaderProg.vertexPositionAttribute = gl.getAttribLocation(shaderProg, 'aVertexPosition');
          gl.enableVertexAttribArray(shaderProg.vertexPositionAttribute);

          shaderProg.pResolutionUniform = gl.getUniformLocation(shaderProg, 'resolution');
          shaderProg.pTimeUniform = gl.getUniformLocation(shaderProg, 'time');
        }

        function initBuffers() {
          var vertices;
          squareVertexPositionBuffer = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);

          vertices = [
             1.0,  1.0, 0.0,
            -1.0,  1.0, 0.0,
             1.0, -1.0, 0.0,
            -1.0, -1.0, 0.0
          ];
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
          squareVertexPositionBuffer.itemSize = 3;
          squareVertexPositionBuffer.numItems = 4;
        }

        function onTextureLoaded(texture) {
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
          gl.bindTexture(gl.TEXTURE_2D, null);
        }

        function initTexture() {
          texture = gl.createTexture();
          texture.image = new Image();
          texture.image.onload = function () {
            onTextureLoaded(texture);
          };
          texture.image.src = window.URL.createObjectURL(video.src);
        }

        function updateTexture() {
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);

          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
          gl.bindTexture(gl.TEXTURE_2D, null);
          // gl.bindTexture(gl.TEXTURE_2D, null);
        }

        function initVideoTexture() {
          texture = gl.createTexture();
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        }

        function setUniforms() {
          var time, diff;

          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.uniform1i(shaderProg.samplerUniform, 0);
          gl.uniform2f(shaderProg.pResolutionUniform, canvas.width, canvas.height);

          time = new Date().getTime();
          diff = time - startTime;

          if (diff > 5000) {
            startTime = new Date().getTime();
          }

          gl.uniform1f(shaderProg.pTimeUniform, diff / 1000.0);
        }


        function draw() {

          updateTexture();

          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
          gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
          gl.vertexAttribPointer(
            shaderProg.vertexPositionAttribute,
            squareVertexPositionBuffer.itemSize,
            gl.FLOAT, false, 0, 0
          );
          setUniforms();
          gl.drawArrays(gl.TRIANGLE_STRIP, 0, squareVertexPositionBuffer.numItems);

          window.requestAnimationFrame(draw);
        }

        function onMediaSuccess(e) {
          var interval;
          video.src = window.URL.createObjectURL(e);

          // this is FUGLY! but i dont give a shit today
          interval = setInterval(function () {
            if (video.readyState === video.HAVE_ENOUGH_DATA) {
              clearInterval(interval);
              window.requestAnimationFrame(draw);
            }
          }, 500);
        }

        function onMediaError(e) {
          alert('an error occured while accessing your webcam');
        }

        function initVideo() {
          video = document.createElement('video');
          video.width = canvas.width;
          video.height = canvas.height;
          video.autoplay = 'autoplay';

          videoCanvas = document.createElement('canvas');
          videoCanvas.width = canvas.width;
          videoCanvas.height = canvas.height;

          videoCtx = videoCanvas.getContext('2d');

          navigator.getUserMedia({'video': true}, onMediaSuccess, onMediaError);
        }

        function init() {
          canvas = document.getElementById('canvas');
          initGl(canvas);
          initShaders();
          initBuffers();
          // initTexture();
          initVideoTexture();
          startTime = new Date().getTime();

          gl.clearColor(0.0, 0.0, 0.0, 1.0);
          gl.disable(gl.DEPTH_TEST);

          if (navigator.getUserMedia) {
            initVideo();
          } else {
            alert('your browser does not support webRTC, download Chrome or Firefox');
            return;
          }
        }

        window.requestAnimationFrame =
          window.requestAnimationFrame   ||
          window.msRequestAnimationFrame ||
          window.mozRequestAnimationFrame;

        navigator.getUserMedia =
          navigator.mozGetUserMedia ||
          navigator.webkitGetUserMedia;

        window.onload = init;
      }());
    </script>
    <script src="assets/menu.js"></script>
  </body>
</html>
