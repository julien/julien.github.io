<!DOCTYPE html>
<html>
<head>
  <style>
    body { overflow:hidden;margin:0;width:100%;height:100%; }
    canvas { display:block;-webkit-transform: translateZ(0); }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <script type="x-shader/x-vertex" id="vs">
    attribute vec2 a_position;
    uniform vec2 u_resolution;

    void main() {
      // convert the rectangle from pixels to [0, 1]
      vec2 zeroToOne = a_position / u_resolution;
      // convert from [0, 1] to [0, 2]
      vec2 zeroToTwo = zeroToOne * 2.0;
      // convert from [0, 2] to [-1, 1] (clipspace)
      vec2 clipSpace = zeroToTwo - 1.0;


      gl_Position = vec4(clipSpace * vec2(1.0, -1.0), 1.0, 1.0);
    }
  </script>

  <script  type="x-shader/x-fragment" id="fs">
    precision mediump float;

    void main() {
      gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
    }
  </script>

  <script>
    window.addEventListener('load', function () {

      var winW = window.innerWidth;
      var winH = window.innerHeight;
      var canvas = document.getElementById('canvas');
      var lastTime = 0;
      var gl;
      var info;

      var aPositionBuffer;
      var aPositions = [];

      var numParticles = 10000;
      var particleSize = 6;

      // universal gravitional constant
      var G = 6.67408 * 2;

      var attractor = {x: winW / 2, y: winH / 2};

      document.addEventListener('mousemove', function (e) {
        attractor.x = e.clientX;
        attractor.y = e.clientY;
      });

      init();

      function init() {
        canvas.width = winW;
        canvas.height = winH;

        gl = canvas.getContext('webgl');
        if (!gl) {
          throw 'Failed to initialize WebGL';
        }


        initShaders();
        initBuffers();

        gl.viewport(0, 0, gl.canvas.clientWidth, gl.canvas.clientHeight);
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.disable(gl.DEPTH_TEST);

        tick();
      }

      function initShaders() {
        var src, vShader, fShader, progam;

        src = document.getElementById('vs').textContent;
        vShader = createShader(gl, src, gl.VERTEX_SHADER);

        src = document.getElementById('fs').textContent;
        fShader = createShader(gl, src, gl.FRAGMENT_SHADER);

        var program = gl.createProgram();
        gl.attachShader(program, vShader);
        gl.attachShader(program, fShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          err = gl.getProgramInfoLog(program);
          gl.deleteProgram(program);
          throw err;
        }

        gl.useProgram(program);

        info = {
          a_position:   gl.getAttribLocation(program, 'a_position'),
          u_resolution: gl.getUniformLocation(program, 'u_resolution')
        };

      }

      function initBuffers() {


        for (var i = 0; i < numParticles; i++) {
          // var x = Math.random() * winW;
          // var y = Math.random() * winH;

          aPositions.push(
              // x, y
              Math.random() * winW,
              Math.random() * winH,

              // vx, vy
              -0.1 + Math.random() * (0.5 - -0.1),
              -0.1 + Math.random() * (0.5 - -0.1),
              // ax, ay
              -0.1 + Math.random() * (0.5 - -0.1),
              -0.1 + Math.random() * (0.5 - -0.1)
          );
        }

        var fsize = Float32Array.BYTES_PER_ELEMENT;
        var stride = fsize * particleSize;

        aPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, aPositionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(aPositions), gl.DYNAMIC_DRAW);

        gl.vertexAttribPointer(info.a_position, 2, gl.FLOAT, false, stride, 0);
        gl.enableVertexAttribArray(info.a_position);
      }

      function tick() {
        var now, elapsed;

        requestAnimationFrame(tick);

        now = new Date().getTime();
        if (lastTime) {
          elapsed = now - lastTime;
          // update animation values
        }
        lastTime = now;
        draw();
      }

      function draw() {
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.uniform2f(info.u_resolution, winW, winH);

        var len = aPositions.length;
        for (var i = 0; i < len; i += particleSize) {

          // x:  aPositions[i]
          // y:  aPositions[i+1]
          // vx: aPositions[i+2]
          // vy: aPositions[i+3]
          // ax: aPositions[i+4]
          // ay: aPositions[i+5]

          var force = {
            x: attractor.x - aPositions[i],
            y: attractor.y - aPositions[i+1]
          };

          var distSq = force.x * force.x + force.y * force.y;
          // distSq = constrain(distSq, 900, 2000);

          var strength = G / distSq;

          var forceMag = Math.sqrt(distSq);
          if (forceMag !== 0) {
            force.x /= forceMag;
            force.y /= forceMag;
          }
          force.x *= strength;
          force.y *= strength;

          // ax, ay = force.x, force.y
          aPositions[i+4] = force.x;
          aPositions[i+5] = force.y;

          // x += vx; y += vy;
          aPositions[i] += aPositions[i+2];
          aPositions[i+1] += aPositions[i+3];

          // vx += ax; vy += ay;
          aPositions[i+2] += aPositions[i+4];
          aPositions[i+3] += aPositions[i+5];

          if (aPositions[i] < 0 ||
              aPositions[i] > winW ||
              aPositions[i+1] < 0 ||
              aPositions[i+1] > winH) {
            aPositions[i] = Math.random() * winW;
            aPositions[i+1] = Math.random() * winH;
            aPositions[i+2] = -0.2 + Math.random() * (0.2 - -0.2);
            aPositions[i+3] = 0;
            aPositions[i+4] = 0;
            aPositions[i+5] = 0;
          }
        }

        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(aPositions), gl.DYNAMIC_DRAW);
        gl.drawArrays(gl.POINTS, 0, aPositions.length / particleSize);
      }

      function createShader(gl, src, type) {
        var shader = gl.createShader(type);
        gl.shaderSource(shader, src);
        gl.compileShader(shader);
        var err;
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          err = gl.getShaderInfoLog(shader);
          gl.deleteShader(shader);
          throw err;
        }
        return shader;
      }

      function randomRange(min, max) {
        return min + Math.random() * (max - min);
      }

      function createRandomVector() {
        var angle = Math.random() * (Math.PI * 2);
        return { x: Math.cos(angle), y: Math.sin(angle) };
      }

      // particle stuff
      function createParticle(x, y) {

        var r = createRandomVector();

        return {
          x: x,
          y: y,
          vx: r.x,
          vy: r.y,
          ax: 0,
          ay: 0
        };
      }

      function constrain(n, low, high) {
        return Math.max(Math.min(n, high), low);
      }

    });
  </script>
</body>
</html>
